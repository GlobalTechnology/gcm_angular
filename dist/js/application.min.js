(function ( angular ) {
	'use strict';
	angular.module( 'gma', [
		'ngRoute',
		'ui.bootstrap',
		'ngResource',
		'gma.controllers',
		'gma.directives',
		'gma.filters',
		'gma.services'
	] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.controllers', [
		'gma.controllers.admin',
		'gma.controllers.map',
		'gma.controllers.measurements',
		'gma.controllers.reports'
	] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.directives', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.filters', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.services', [
		'gma.services.measurements',
		'gma.services.settings'
	] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.controllers.admin', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.controllers.map', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.controllers.measurements', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.controllers.reports', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.services.measurements', [] );
})( angular );

(function ( angular ) {
	'use strict';
	angular.module( 'gma.services.settings', [] );
})( angular );

angular.module( 'gma' )
	.run( function ( $rootScope, $route, $location, sessionService, settings ) {
		// Object to hold current values: assignments, assignment, user ...
		$rootScope.current = {
			isLoaded: false
		};
		$rootScope.visibleTabs = settings.enabledTabs;

		// Support application inside an iframe, sync parent hash.
		if ( typeof window.parent !== 'undefined' ) {
			var parentHash = window.parent.location.hash;
			if ( parentHash ) {
				$location.path( parentHash.slice( 1 ) );
			}

			$rootScope.$on( '$locationChangeSuccess', function () {
				window.parent.location.hash = '#' + $location.path();
			} );
		}

		// Reload the route since ng-view directive is inside a template.
		$route.reload();

		// Start the session with the API
		//TODO fetch a ticket from refresh to start session
		sessionService.startSession( settings.ticket );
	} )
	.config( function ( $routeProvider, $httpProvider, $compileProvider, settingsProvider, $provide ) {
		// Initialize Settings from wrapper provided config
		settingsProvider.setConfig( window.gma.config );

		// Add itms-services scheme to safe aHref protocols
		$compileProvider.aHrefSanitizationWhitelist( /^\s*(https?|ftp|mailto|tel|file|itms-services):/ );

		// Register sessionService as an http interceptor
		$httpProvider.interceptors.push( 'sessionService' );

		// Setup application routes
		// angularAMD is used to provide on demand controller loading
		angular.forEach( settingsProvider.routes(), function ( route, i ) {
			if ( i === 0 ) {
				$routeProvider.otherwise( {redirectTo: route.path} );
			}
			$routeProvider
				.when( route.path, {
					templateUrl: route.templateUrl,
					controller:  route.controller
				} );
		} );

		// https://github.com/angular/angular.js/issues/1404
		// Source: http://plnkr.co/edit/hSMzWC?p=preview
		$provide.decorator( 'ngModelDirective', function ( $delegate ) {
			var ngModel = $delegate[0], controller = ngModel.controller;
			ngModel.controller = ['$scope', '$element', '$attrs', '$injector', function ( scope, element, attrs, $injector ) {
				var $interpolate = $injector.get( '$interpolate' );
				attrs.$set( 'name', $interpolate( attrs.name || '' )( scope ) );
				$injector.invoke( controller, this, {
					'$scope':   scope,
					'$element': element,
					'$attrs':   attrs
				} );
			}];
			return $delegate;
		} );

		$provide.decorator( 'formDirective', function ( $delegate ) {
			var form = $delegate[0], controller = form.controller;
			form.controller = ['$scope', '$element', '$attrs', '$injector', function ( scope, element, attrs, $injector ) {
				var $interpolate = $injector.get( '$interpolate' );
				attrs.$set( 'name', $interpolate( attrs.name || attrs.ngForm || '' )( scope ) );
				$injector.invoke( controller, this, {
					'$scope':   scope,
					'$element': element,
					'$attrs':   attrs
				} );
			}];
			return $delegate;
		} );
	} );

(function () {
	'use strict';

	function GMACtrl( $scope, $filter, $location, $modal, sessionService, ministryService, assignmentService, settings, $log ) {
		// Attach $location provider to scope, this is used to set active tabs
		$scope.$location = $location;

		//---------------------------------------
		// Assignments
		//---------------------------------------

		$scope.$on( 'sessionStart', function ( event, session ) {
			if ( typeof session.assignments === 'undefined' ) {
				//Open Modal if user has no assignment
				$scope.joinMinistry( false );
			}
		} );

		// Update current assignment when assignments is set - this occurs after a session is established
		$scope.$watch( 'current.assignments', function ( assignments, oldVal ) {
			if ( assignments === oldVal ) return;

			$log.debug( 'Assignments Changed' );

			if ( typeof assignments === 'object' ) {
				if ( angular.isUndefined( $scope.current.assignment ) || !_.contains( _.pluck( assignments, 'id' ), $scope.current.assignment.id ) ) {
					$scope.current.assignment = $filter( 'orderBy' )( assignments, 'name' )[0];
				}
				$scope.current.ministries = flattenMinistries( assignments );
			} else {
				delete $scope.current.assignment;
				$scope.current.ministries = [];
			}
		} );

		// Update assignment and mcc when assignment changes
		$scope.$watch( 'current.assignment', function ( assignment, oldVal ) {
			if ( assignment === oldVal ) return;

			$log.debug( 'Assignment Changed: ' + assignment.name );

			if ( typeof assignment === 'object' ) {

				if ( assignment.mccs.length > 0 ) {
					// Set mcc if none is currently set or new assignment does not include current mcc
					if ( typeof $scope.current.mcc === 'undefined' || assignment.mccs.indexOf( $scope.current.mcc ) < 0 ) {
						$scope.current.mcc = $filter( 'orderBy' )( assignment.mccs, $scope.mccSort )[0];
					}
				}
				else {
					// Delete current mcc if assignment has no mccs
					delete $scope.current.mcc;
				}
			}
		} );

		$scope.current.hasRole = function ( role ) {
			if ( typeof $scope.current.assignment === 'undefined' || typeof $scope.current.assignment.team_role === 'undefined' ) return false;
			return (typeof role === 'string') ? role == $scope.current.assignment.team_role : _.contains( role, $scope.current.assignment.team_role );
		};

		function flattenMinistries( arr ) {
			var ministries = [];
			angular.forEach( arr, function ( ministry ) {
				ministries.push( ministry );
				if ( ministry.hasOwnProperty( 'sub_ministries' ) && typeof ministry.sub_ministries === 'object' ) {
					ministries = ministries.concat( flattenMinistries( ministry.sub_ministries ) );
				}
			} );

			//sort by team role
			ministries = _.sortBy( ministries, function ( m ) {
				return (m.team_role === 'leader' ? 0 : 1);
			} );
			//remove duplicates
			return _.uniq( ministries, false, function ( m ) {
				return m.ministry_id;
			} );
		}

		//---------------------------------------
		// Mission Critical Components (MCC)
		//---------------------------------------

		// MCC labels, this should be done in localization in the future.
		$scope.mccLabels = {
			ds:  'Digital Strategies',
			gcm: 'Global Church Movements',
			llm: 'Leader Led',
			slm: 'Student Led'
		};

		$scope.mccSort = function ( value ) {
			return $scope.mccLabels[value];
		};

		//---------------------------------------
		// Periods
		//---------------------------------------
		var periods = [], now = moment().date( 1 );
		for ( var i = 0; i < 12; i++ ) {
			periods.push( now.clone() );
			now.subtract( 1, 'M' );
		}
		$scope.periods = periods;
		$scope.current.period = periods[0];

		$scope.prevPeriod = function () {
			var index = $scope.periods.indexOf( $scope.current.period );
			index = ( ( index + 1 ) >= $scope.periods.length ) ? 0 : index + 1;
			$scope.current.period = $scope.periods[index];
		};

		$scope.nextPeriod = function () {
			var index = $scope.periods.indexOf( $scope.current.period );
			index = ( ( index - 1 ) < 0 ) ? $scope.periods.length - 1 : index - 1;
			$scope.current.period = $scope.periods[index];
		};

		//---------------------------------------
		// Session
		//---------------------------------------

		$scope.logout = function () {
			sessionService.logout().then( function () {
				window.location = settings.api.logout;
			} );
		};

		$scope.invalidateSession = function () {
			sessionService.logout();
		};

		$scope.joinMinistry = function ( allowClose ) {
			allowClose = typeof allowClose !== 'undefined' ? allowClose : true;
			var instance = $modal.open( {
				templateUrl: 'partials/join-ministry.html',
				controller:  'JoinMinistryCtrl',
				keyboard:    allowClose,
				backdrop:    allowClose ? true : 'static',
				resolve:     {
					'ministries': function () {
						return ministryService.getMinistries().$promise;
					},
					'allowClose': function () {
						return allowClose;
					}
				}
			} );
			instance.result.then( function ( ministry ) {
				assignmentService.addTeamMember( {
					username:    $scope.current.user.cas_username,
					ministry_id: ministry.ministry_id,
					team_role:   'self_assigned'
				}, function ( assignment ) {
					if ( typeof $scope.current.assignments === 'undefined' ) {
						// If assignments is empty, setting the array will also set the current assignment
						$scope.current.assignments = [assignment];
					}
					else {
						// Add new assignment
						$scope.current.assignments.push( assignment );

						// Set new assignment as current
						$scope.current.assignment = assignment;
					}
				} );
			} );
		};

		$scope.onError = function ( response, code ) {
			if ( code == 401 && response.hasOwnProperty( 'reason' ) ) {
				if ( response.reason == 'SESSION_INVALID' ) {
					window.location = window.location.pathname;
				}
			}
			$scope.error = response.reason;
		};

		$scope.mobileApps = settings.mobileApps;
	}

	angular.module( 'gma.controllers' ).controller( 'GMACtrl', GMACtrl );
})();

(function () {
	'use strict';

	function JoinMinistryCtrl( $scope, $modalInstance, ministries, allowClose ) {
		$scope.ministries = ministries;
		$scope.allowClose = allowClose;

		$scope.join = function () {
			$modalInstance.close( $scope.ministry );
		};

		$scope.cancel = function () {
			$modalInstance.dismiss( 'cancel' );
		};
	}

	angular.module( 'gma.controllers' ).controller( 'JoinMinistryCtrl', JoinMinistryCtrl );
})();

(function () {
	'use strict';

	angular.module( 'gma.directives' )
		.directive( 'gmaTrend', [function () {
			return {
				restrict: 'A',
				require:  'ngModel',
				link:     function ( $scope, $element, $attrs, ngModel ) {
					if ( !ngModel ) return;
					var chart = new google.visualization.LineChart( $element.get( 0 ) );

					ngModel.$render = function () {
						chart.draw( ngModel.$viewValue, {width: 550, height: 200} );
					};

					$scope.$on( '$destroy', function () {
						chart = null;
					} );
				}
			}
		}] )
})();

(function () {
	'use strict';

	angular.module( 'gma' )
		.filter( 'roleFilter', [function () {
			return function ( items, role ) {
				var filtered = [];
				angular.forEach( items, function ( item ) {
					if ( typeof role === 'string' && role == item.team_role ) {
						filtered.push( item );
					} else if ( typeof role === 'object' && _.contains( role, item.team_role ) ) {
						filtered.push( item );
					}
				} );
				return filtered;
			};
		}] );
})();

(function () {
	'use strict';
	
	function AdminCtrl( $scope, $modal, $filter, assignmentService, ministryService, measurementTypeService ) {
		$scope.current.isLoaded = false;

		$scope.roles = [
			{value: "leader", text: 'Leader'},
			{value: "inherited_leader", text: "Leader (inherited)"},
			{value: "member", text: 'Member'},
			{value: "blocked", text: 'Blocked'},
			{value: "self_assigned", text: 'Self Assigned'}
		];

		$scope.$watch( 'current.assignment.ministry_id', function ( ministry_id ) {
			if ( typeof ministry_id === 'undefined' ) return;
			$scope.ministry = ministryService.getMinistry( {ministry_id: ministry_id}, function () {
				$scope.current.isLoaded = true;

				$scope.measurementTypes = [];
				measurementTypeService.getMeasurementTypes().$promise.then( function ( data ) {
					angular.forEach( data, function ( type ) {
						if ( type.is_custom && _.contains( $scope.ministry.lmi_show, type.perm_link_stub ) ) {
							type.visible = true;
						} else if ( !type.is_custom && !_.contains( $scope.ministry.lmi_hide, type.perm_link_stub ) ) {
							type.visible = true;
						} else {
							type.visible = false;
						}
						$scope.measurementTypes.push( type );
					} );
				} );
			} );
		} );

		$scope.saveRole = function ( assignment ) {
			assignmentService.saveAssignment( {
				assignment_id: assignment.assignment_id
			}, {team_role: assignment.team_role} );
		};

		$scope.ableToChangeParentMinistry = function ( parentToFind ) {
			var availableMinIds = _.pluck( $filter( 'roleFilter' )( $scope.current.ministries, ['leader', 'inherited_leader'] ), 'ministry_id' )
			return _.contains( availableMinIds, parentToFind );
		};

		$scope.addTeamMember = function () {
			$modal.open( {
				templateUrl: 'partials/admin/add-team-member.html',
				controller:  function ( $scope, $modalInstance, roles ) {
					$scope.roles = roles;

					$scope.close = function () {
						$modalInstance.dismiss();
					};

					$scope.add = function () {
						$modalInstance.close( $scope.newMember );
					};
				},
				resolve:     {
					'roles': function () {
						return $scope.roles;
					}
				}
			} ).result.then( function ( newMember ) {
					newMember.ministry_id = $scope.current.assignment.ministry_id;
					assignmentService.addTeamMember( newMember, function () {
						$scope.ministry = ministryService.getMinistry( {ministry_id: $scope.current.assignment.ministry_id} );
					} );
				} );
		};

		$scope.addSubMinistry = function () {
			$modal.open( {
				templateUrl: 'partials/admin/add-sub-ministry.html',
				controller:  function ( $scope, $modalInstance ) {
					$scope.close = function () {
						$modalInstance.dismiss();
					};

					$scope.add = function () {
						$modalInstance.close( $scope.newMinistry );
					};
				}
			} ).result.then( function ( newMinistry ) {
					newMinistry.parent_id = $scope.current.assignment.ministry_id;
					ministryService.createMinistry( newMinistry, function () {
						if ( angular.isDefined( $scope.current.assignment.sub_ministries ) ) {
							$scope.current.assignment.sub_ministries.push( newMinistry );
						} else {
							$scope.current.assignment.sub_ministries = [newMinistry];
						}
					} );
				} );
		};

		$scope.addMeasurement = function () {
			$modal.open( {
				templateUrl: 'partials/admin/add-measurement-type.html',
				controller:  function ( $scope, $modalInstance ) {
					$scope.close = function () {
						$modalInstance.dismiss();
					};

					$scope.add = function () {
						$modalInstance.close( $scope.newMeasurement );
					};
				}
			} ).result.then( function ( newMeasurement ) {
					newMeasurement.perm_link_stub = 'custom_' + newMeasurement.perm_link_stub;
					measurementTypeService.addMeasurementType( newMeasurement, function () {
					} );
				} );
		};

		$scope.saveDetails = function () {
			var ministry = {
				ministry_id: $scope.ministry.ministry_id,
				min_code:    $scope.ministry.min_code,
				name:        $scope.ministry.name,
				has_ds:      $scope.ministry.has_ds,
				has_gcm:     $scope.ministry.has_gcm,
				has_llm:     $scope.ministry.has_llm,
				has_slm:     $scope.ministry.has_slm,
				private:     $scope.ministry.private,
				lmi_hide:    _.pluck( _.where( $scope.measurementTypes, {
					is_custom: false,
					visible:   false
				} ), 'perm_link_stub' ),
				lmi_show:    _.pluck( _.where( $scope.measurementTypes, {
					is_custom: true,
					visible:   true
				} ), 'perm_link_stub' )
			};
			if ( $scope.ministry.hasOwnProperty( 'parent_id' ) && typeof $scope.ministry.parent_id === "string" ) {
				ministry.parent_id = $scope.ministry.parent_id;
			}
			$scope.saveDetailsResource = ministryService.updateMinistry( ministry,
				function () {
					$scope.saveDetailsAlert = {
						type: 'success',
						msg:  'Your changes have been saved.'
					};
				}, function ( response ) {
					$scope.saveDetailsAlert = {
						type: 'danger',
						msg:  response.Message || 'An error occurred while saving.'
					};
				} );
		};
	}

	angular.module( 'gma.controllers.admin' ).controller( 'AdminCtrl', AdminCtrl );
}());

(function ( $ ) {
	'use strict';

	function MapCtrl( $scope, $document, $compile, trainingService, churchService, ministryService, settings ) {
		$scope.current.isLoaded = false;
		$scope.versionUrl = settings.versionUrl;
		$scope.show_target_point = true;
		$scope.show_group = true;
		$scope.show_church = true;
		$scope.show_mult_church = true;
		$scope.show_lines = true;
		$scope.show_lines = true;
		$scope.show_jf = true;
		$scope.map_filter = 'min_only';
		$scope.icon_add_mode = false;
		$scope.show_all = "year";
		$scope.show_tree = false;
		$scope.new_church = {};
		$scope.edit_church = {};
		$scope.SetParentMode = false;
		$scope.church_lines = [];
		$scope.churches = [];
		$scope.trainings = [];
		$scope.allChurches = [];
		$scope.training_types = [
			{value: "MC2", text: 'MC2'},
			{value: "T4T", text: 'T4T'},
			{value: "CPMI", text: 'CPMI'},
			{value: "", text: 'Other'}
		];
		$scope.show = {
			training: true
		};
		$scope.mapOptions = {
			zoom:               3,
			center:             new google.maps.LatLng( 0, 0 ),
			panControl:         true,
			zoomControl:        true,
			mapTypeControl:     true,
			streetViewControl:  false,
			overviewMapControl: false
		};
		setTimeout( initialize, 0 );

		function initialize() {
			$scope.map = new google.maps.Map( document.getElementById( 'map_canvas' ), $scope.mapOptions );
			$scope.map.setOptions( {draggableCursor: ''} );

			google.maps.event.addListener( $scope.map, "idle", function () {
				$scope.current.isLoaded = true;
				var bounds = $scope.map.getBounds(),
					ne = bounds.getNorthEast(),
					sw = bounds.getSouthWest();

				if ( ne.lat() == sw.lat() && ne.lng() == sw.lng() ) {
					// Trigger a resize if bounds have 0 area
					google.maps.event.trigger( $scope.map, 'resize' );
				}
				else {
					$scope.loadChurches();
				}
			} );
			$scope.map.markers = [];
			$scope.church = {name: ""};

			$scope.churchWindow = new google.maps.InfoWindow();
			$scope.churchWindowContent = $compile( '<div id="church_window_content" ng-include="\'partials/map/edit-church.html\'"></div>' )( $scope )
			$scope.churchWindow.setOptions( {maxWidth: 300} );
			$scope.trainingWindow = new google.maps.InfoWindow();
			$scope.trainingWindowContent = $compile( '<div id="training_window_content" ng-include="\'partials/map/edit-training.html\'"></div>' )( $scope )
			$scope.trainingWindow.setOptions( {maxWidth: 400} );

			$scope.newChurchWindow = new google.maps.InfoWindow();
			google.maps.event.addListener( $scope.newChurchWindow, 'closeclick', function () {
				$scope.cancelAddChurch();
			} );
			$scope.newChurchWindowContent = $compile( '<div id="new_church_window_content" ng-include="\'partials/map/new-church.html\'"></div>' )( $scope );


			$scope.newTrainingWindow = new google.maps.InfoWindow();
			google.maps.event.addListener( $scope.newTrainingWindow, 'closeclick', function () {
				$scope.cancelAddChurch();
			} );
			$scope.newTrainingContent = $compile( '<div id="new_training_window_content" ng-include="\'partials/map/new-training.html\'"></div>' )( $scope );

			$scope.map.church_lines = [];
			$scope.map.icons = {};
			$scope.map.icons.church = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/church.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 30, 58 )
			);
			$scope.map.icons.cluster = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/cluster.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 30, 31 )
			);
			$scope.map.icons.multiplying = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/multiplying.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 30, 53 )
			);
			$scope.map.icons.group = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/group.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 30, 55 )
			);
			$scope.map.icons.targetpoint = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/target.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 32, 56 )
			);
			$scope.map.icons.training = new google.maps.MarkerImage(
				settings.versionUrl( 'img/icon/training.png' ),
				new google.maps.Size( 60, 60 ),
				new google.maps.Point( 0, 0 ),
				new google.maps.Point( 30, 43 )
			);

			$scope.map.side = document.getElementById( 'side' );
			$scope.map.side.index = -1;
			$scope.map.side.style.display = 'block';
			$scope.map.search = document.getElementById( 'map_controls' );
			$scope.map.search.index = 3;
			$scope.map.search.style.display = 'block';

			$scope.map.controls[google.maps.ControlPosition.TOP_RIGHT].push( $scope.map.side );
			$scope.map.controls[google.maps.ControlPosition.TOP_LEFT].push( $scope.map.search );
			if ( $scope.current.assignment )$scope.load_training_markers();

			$scope.$watch( 'current.assignment', function ( a, oldVal ) {
				if ( typeof a !== 'undefined' ) {

					if ( a && a.hasOwnProperty( 'location' ) ) {
						$scope.map.setCenter( new google.maps.LatLng( a.location.latitude, a.location.longitude ) );
					}
					if ( a && a.hasOwnProperty( 'location_zoom' ) ) {
						$scope.map.setZoom( parseInt( a.location_zoom ) );
					}
				}
			}, true );
		}

		$scope.$watch( 'current.assignment.ministry_id', function ( ministry_id ) {
			if ( typeof ministry_id === 'undefined' ) {
				$scope.allChurches = [];
				$scope.trainings = [];
			} else {
				$scope.loadAllChurches();
				$scope.loadTrainings();
			}
		} );

		$scope.$watch( 'searchedChurch', function ( church ) {
			if ( typeof church === 'undefined' || church == '' ) return;
			var markers = $scope.map.markers.filter( function ( c ) {
				return c.id == church.id
			} );
			if ( markers.length > 0 ) {
				var marker = markers[0];
				google.maps.event.trigger( marker, 'click' );
			}
			else {
				$scope.map.setCenter( new google.maps.LatLng( church.latitude, church.longitude ) );
			}
		} );

		$scope.$watch( 'map_filter', function ( filter ) {
			$scope.loadAllChurches();
			$scope.loadTrainings();
		} );

		$scope.$watch( 'current.mcc', function ( mcc ) {
			if ( typeof mcc === 'undefined' ) {
				$scope.trainings = [];
			} else {
				$scope.loadTrainings();
			}
		} );

		$scope.loadAllChurches = _.debounce( function () {
			if ( typeof $scope.current.assignment === 'undefined' ) return;
			var params = {
				ministry_id: $scope.current.assignment.ministry_id
			};
			if ( $scope.map_filter === 'everything' ) {
				params['show_all'] = 'true';
			} else if ( $scope.map_filter === 'tree' ) params['show_tree'] = 'true';

			$scope.allChurches = churchService.getChurches( params );
		}, 500 );

		$scope.loadTrainings = _.debounce( function () {
			// Member, Leader and Inherited can view trainings
			if ( typeof $scope.current.assignment !== 'undefined' && $scope.current.hasRole( ['leader', 'inherited_leader'] ) ) {
				trainingService.getTrainings( $scope.current.sessionToken, $scope.current.assignment.ministry_id, $scope.current.mcc, $scope.show_all == "all", $scope.show_tree ).then( function ( trainings ) {
					$scope.trainings = trainings;
				}, $scope.onError );
			}
			else {
				$scope.trainings = [];
			}
		}, 500 );

		$scope.loadChurches = _.debounce( function () {
			if ( typeof $scope.current.assignment === 'undefined' ) return;

			console.log( 'loading churches' );
			var bounds = $scope.map.getBounds(),
				ne = bounds.getNorthEast(),
				sw = bounds.getSouthWest(),
				params = {
					ministry_id: $scope.current.assignment.ministry_id,
					lat_min:     sw.lat(),
					lat_max:     ne.lat(),
					long_min:    sw.lng(),
					long_max:    ne.lng()
				};
			if ( !$scope.show_target_point ) params['hide_target_point'] = 'true';
			if ( !$scope.show_group ) params['hide_group'] = 'true';
			if ( !$scope.show_church ) params['hide_church'] = 'true';
			if ( !$scope.show_mult_church ) params['hide_mult_church'] = 'true';
			if ( $scope.map_filter === 'everything' ) {
				params['show_all'] = 'true';
			} else if ( $scope.map_filter === 'tree' ) params['show_tree'] = 'true';

			// Disable clustering at Zoom 14 and higher
			if ( $scope.map.getZoom() >= 14 ) params['should_cluster'] = 'false';

			churchService.getChurches( params ).$promise.then( $scope.onGetChurches, $scope.onError );
		}, 500 );

		$scope.removeLines = function () {
			angular.forEach( $scope.map.church_lines, function ( l ) {
				l.setMap( null );
			} );
		};

		$scope.removeJF = function () {
			$( '.jf_label' ).remove();
		};

		$scope.$watch( 'show_lines', function () {
			if ( typeof $scope.map !== 'undefined' ) {
				angular.forEach( $scope.map.church_lines, function ( line ) {
					line.setVisible( $scope.show_lines );
				} );
			}
		} );

		$scope.$watch( 'show_jf', function () {
			if ( $scope.show_jf ) {
				$( '.jf_label' ).show();
			} else {
				$( '.jf_label' ).hide();
			}
		} );

		$scope.onAddChurch = function () {
			$scope.loadChurches();
		};

		$scope.addChurch = function () {
			angular.forEach( $scope.map.markers, function ( m ) {

				if ( m.id == -1 ) {
					$scope.new_church.ministry_id = $scope.current.assignment.ministry_id;

					$scope.new_church.latitude = m.getPosition().lat();
					$scope.new_church.longitude = m.getPosition().lng();
					console.log( $scope.new_church );
					churchService.addChurch( $scope.new_church ).$promise.then( $scope.onAddChurch, $scope.onError );

					m.setMap( null );
					var removedObject = $scope.map.markers.splice( $scope.map.markers.indexOf( m ), 1 );

					removedObject = null;
				}
			} );
		};

		$scope.addTraining = function () {
			angular.forEach( $scope.map.markers, function ( m ) {

				if ( m.id == -2 ) {
					$scope.new_training.ministry_id = $scope.current.assignment.ministry_id;
					$scope.new_training.latitude = m.getPosition().lat();
					$scope.new_training.longitude = m.getPosition().lng();
					$scope.new_training.mcc = $scope.current.mcc;
					trainingService.addTraining( $scope.current.sessionToken, $scope.new_training ).then(
						$scope.loadTrainings,
						$scope.onError
					);

					m.setMap( null );
					var removedObject = $scope.map.markers.splice( $scope.map.markers.indexOf( m ), 1 );

					removedObject = null;
				}
			} );
		};

		$scope.cancelAddChurch = function () {
			angular.forEach( $scope.map.markers, function ( m ) {
				if ( m.id < 0 ) {

					m.setMap( null );
					var removedObject = $scope.map.markers.splice( $scope.map.markers.indexOf( m ), 1 );

					removedObject = null;
				}
			} );
			$scope.new_church = {};
			$scope.new_training = {};
		};

		$scope.onAddTraining = function () {
			if ( $scope.map.markers.filter( function ( c ) {
					return c.id < 0
				} ).length == 0 ) {
				$scope.new_training = {};

				var marker = new MarkerWithLabel( {
					position:          $scope.map.getCenter(),
					map:               $scope.map,
					title:             "new_training",
					id:                -2,
					cluster_count:     1,
					zIndex:            9999,
					icon:              $scope.map.icons.training,
					labelContent:      'MOVE ME!',
					labelAnchor:       new google.maps.Point( 50, -5 ),
					labelClass:        "labelMoveMarker", // the CSS class for the label
					labelInBackground: false,
					draggable:         true
				} );
				$scope.map.new_training_marker = marker;
				marker.setAnimation( google.maps.Animation.BOUNCE );

				if ( !$scope.newTrainingWindow.getContent() ) {
					$scope.newTrainingWindow.setContent( $scope.newTrainingContent[0].nextSibling );
				}
				$scope.newTrainingWindow.open( $scope.map, marker );

				$scope.map.markers.push( marker );
			}
		};

		$scope.onSaveChurch = function ( response ) {
			$scope.loadChurches();
		};

		$scope.onAddIcon = function () {
			if ( $scope.map.markers.filter( function ( c ) {
					return c.id < 0
				} ).length == 0 ) {
				$scope.new_church = {security: 2};

				var marker = new MarkerWithLabel( {
					position:          $scope.map.getCenter(),
					map:               $scope.map,
					title:             "new church",
					id:                -1,
					cluster_count:     1,
					zIndex:            9999,
					icon:              $scope.map.icons.targetpoint,
					labelContent:      'Move me!',
					labelAnchor:       new google.maps.Point( 50, -20 ),
					labelClass:        "labelMoveMarker", // the CSS class for the label
					labelInBackground: false,
					draggable:         true
				} );
				$scope.map.new_marker = marker;
				marker.setAnimation( google.maps.Animation.BOUNCE );
				//$scope.$apply();
				if ( !$scope.newChurchWindow.getContent() ) {
					$scope.newChurchWindow.setContent( $scope.newChurchWindowContent[0].nextSibling );
				}
				$scope.newChurchWindow.open( $scope.map, marker );

				$scope.map.markers.push( marker );
			}
		};

		$scope.SetParent = function () {
			$scope.SetParentMode = true;
			$scope.churchWindow.close();
			$scope.new_parentLine = new google.maps.Polyline( {
				path:          [new google.maps.LatLng( $scope.edit_church.latitude, $scope.edit_church.longitude ), new google.maps.LatLng( $scope.edit_church.latitude, $scope.edit_church.longitude )],
				geodesic:      true,
				strokeColor:   '#777',
				strokeOpacity: 1.0,
				strokeWeight:  2,
				icons:         [{
									icon:   {
										path:         google.maps.SymbolPath.FORWARD_OPEN_ARROW,
										strokeWeight: 1.5
									},
									offset: '12px',
									repeat: '25px'
								}]
			} );

			$scope.move_event = google.maps.event.addListener( $scope.map, 'mousemove', function ( e ) {
				$scope.new_parentLine.setPath( [e.latLng, new google.maps.LatLng( $scope.edit_church.latitude, $scope.edit_church.longitude )] );
			} );

			$scope.new_parentLine.setMap( $scope.map );
			//   $scope.map.church_lines.push(parentLine);
		};

		$scope.MoveChurch = function () {
			angular.forEach( $scope.map.markers, function ( m ) {
				if ( m.id === $scope.edit_church.id ) {
					m.setAnimation( google.maps.Animation.BOUNCE );
					m.setDraggable( true );
					$scope.churchWindow.close();
				}
			} );
		};

		$scope.MoveTraining = function () {
			var id = $scope.edit_training.hasOwnProperty( 'Id' ) ? $scope.edit_training.Id : $scope.edit_training.id;
			angular.forEach( $scope.map.markers, function ( m ) {
				if ( m.id === 't' + id ) {
					m.setAnimation( google.maps.Animation.BOUNCE );
					m.setDraggable( true );
					$scope.trainingWindow.close();
				}
			} );
		};

		$scope.SaveChurch = function () {
			churchService.saveChurch( $scope.edit_church ).$promise.then( $scope.onSaveChurch, $scope.onError );
		};

		$scope.SaveTraining = function () {
			trainingService.updateTraining( $scope.current.sessionToken, $scope.edit_training ).then( $scope.onSaveChurch, $scope.onError );
		};

		$scope.$watch( 'trainings', function () {
			if ( $scope.map ) {
				$scope.load_training_markers();
			}
		} );

		$scope.load_training_markers = function () {
			if ( typeof $scope.map === 'undefined' ) return;
			var toDelete = [];
			angular.forEach( $scope.map.markers, function ( training ) {
				if ( training.id[0] == 't' && $scope.trainings.filter( function ( t ) {
						return t.id == training.id
					} ).length == 0 ) {
					toDelete.push( training );
				}
				else if ( training.id[0] == 't' && !$scope.show.training ) toDelete.push( training );
			} );

			angular.forEach( toDelete, function ( training ) {
				training.setMap( null );
				var removedObject = $scope.map.markers.splice( $scope.map.markers.indexOf( training ), 1 );
				removedObject = null;
			} );

			if ( $scope.show.training ) {
				angular.forEach( $scope.trainings, function ( training ) {
					if ( $scope.map.markers.filter( function ( c ) {
							return c.id === 't' + training.id
						} ).length == 0 ) {
						if ( training.longitude ) {
							var marker = new MarkerWithLabel( {
								position:          new google.maps.LatLng( training.latitude, training.longitude ),
								map:               $scope.map,
								id:                't' + ( training.hasOwnProperty( 'Id' ) ? training.Id : training.id ),
								title:             training.type,
								icon:              $scope.map.icons.training,
								labelContent:      '', //training.type + '<span class="map-trained-count">' + training.leaders_trained + '</span>',
								labelAnchor:       new google.maps.Point( 30, 0 ),
								labelClass:        "labelMarker", // the CSS class for the label
								labelInBackground: false,
								draggable:         false
							} );
							if ( !$scope.trainingWindow.getContent() ) {
								$scope.trainingWindow.setContent( $scope.trainingWindowContent[0].nextSibling );
							}

							google.maps.event.addListener( marker, 'click', (function ( training, marker ) {
								return function () {
									//$scope.church = marker;
									$scope.edit_training = training;
									$scope.edit_training.editable = (($scope.current.assignment.team_role === 'leader' || $scope.current.assignment.team_role === 'inherited_leader') && training.ministry_id === $scope.current.assignment.ministry_id);

									$scope.$apply();
									$scope.trainingWindow.close();
									$scope.trainingWindow.setOptions( {maxWidth: 400} );
									$scope.trainingWindow.open( $scope.map, marker );
									// $scope.churchWindow.open($scope.map, marker);
								}
							}( training, marker, $scope )) );

							google.maps.event.addListener( marker, 'dragend', (function () {
								console.log( marker );
								training.latitude = marker.getPosition().lat();
								training.longitude = marker.getPosition().lng();
								trainingService.updateTraining( $scope.current.sessionToken, training ).then( $scope.onSaveChurch, $scope.onError );
								marker.setAnimation( null );
								marker.setDraggable( false );
							}) );

							$scope.map.markers.push( marker );
						}
					}
				} );
			}
		};

		$scope.$watch( 'show.training', $scope.load_training_markers, true );

		$scope.onGetChurches = function ( response ) {
			$scope.churches = response;
			console.log( 'got churches' );
			$scope.removeLines();
			$scope.removeJF();
			// $scope.map.markers = [];

			// do more intelligent replace
			//remove elements that are not in the new one.
			var toDelete = [];

			angular.forEach( $scope.map.markers, function ( church ) {
				if ( church.id > 0 ) {
					if ( response.filter( function ( c ) {
							return c.id == church.id && c.cluster_count == 1
						} ).length == 0 || church.cluster_count > 1 ) {
						toDelete.push( church );
					}
				}
			} );

			angular.forEach( toDelete, function ( church ) {
				//console.log(toDelete)
				//var church = $scope.map.markers.filter(function (c) { return c.id == toDelete[i] });
				//console.log(church.length);
				church.setMap( null );
				var removedObject = $scope.map.markers.splice( $scope.map.markers.indexOf( church ), 1 );

				removedObject = null;
			} );


			angular.forEach( $scope.churches, function ( church ) {
				if ( $scope.map.markers.filter( function ( c ) {
						return c.id == church.id
					} ).length == 0 ) {
					var marker = {};

					if ( church.cluster_count == 1 ) {
						var churchIconToUse = {}
						if ( church.development == 5 ) {
							churchIconToUse = $scope.map.icons.multiplying;
						}
						else if ( church.development == 4 ) {
							churchIconToUse = $scope.map.icons.church;
						}
						else if ( church.development == 3 ) {
							churchIconToUse = $scope.map.icons.church;
						}
						else if ( church.development == 2 ) {
							churchIconToUse = $scope.map.icons.group;
						}
						else if ( church.development == 1 ) {
							churchIconToUse = $scope.map.icons.targetpoint;
						}
						else {
							churchIconToUse = $scope.map.icons.church;
						}

						marker = new MarkerWithLabel( {
							position:          new google.maps.LatLng( church.latitude, church.longitude ),
							map:               $scope.map,
							title:             church.name,
							id:                church.id,
							cluster_count:     church.cluster_count,
							icon:              churchIconToUse,
							labelContent:      church.name,
							labelAnchor:       new google.maps.Point( 30, 0 ),
							labelClass:        "labelMarker", // the CSS class for the label
							labelInBackground: false,
							draggable:         false
						} );
						if ( church.jf_contrib > 0 ) church.jf = new $scope.jesusFilmSign( new google.maps.LatLng( church.latitude, church.longitude ), church.jf_contrib, church.development );
					}
					else {
						marker = new MarkerWithLabel( {
							position:          new google.maps.LatLng( church.latitude, church.longitude ),
							map:               $scope.map,
							id:                church.id,
							cluster_count:     church.cluster_count,
							icon:              $scope.map.icons.cluster,
							labelContent:      church.cluster_count.toString(),
							labelAnchor:       new google.maps.Point( 30, 15 ),
							labelClass:        "clusterMarker", // the CSS class for the label
							labelInBackground: false

						} );
						if ( church.jf_contrib > 0 ) church.jf = new $scope.jesusFilmSign( new google.maps.LatLng( church.latitude, church.longitude ), church.jf_contrib, 'cluster' );

					}
					if ( !$scope.churchWindow.getContent() ) {
						$scope.churchWindow.setContent( $scope.churchWindowContent[0].nextSibling );
					}

					google.maps.event.addListener( marker, 'click', (function ( church, marker ) {
						return function () {
							if ( $scope.SetParentMode ) {
								if ( church.cluster_count == 1 && church.id !== $scope.edit_church.id ) {
									google.maps.event.removeListener( $scope.move_event );
									$scope.SetParentMode = false;
									$scope.new_parentLine.setPath( [new google.maps.LatLng( church.latitude, church.longitude ), new google.maps.LatLng( $scope.edit_church.latitude, $scope.edit_church.longitude )] );
									//update church's parent
									var new_church = {};
									new_church.id = $scope.edit_church.id;
									new_church.parent_id = church.id;
									$scope.edit_church.parent_id = church.id;
									console.log( new_church );
									churchService.saveChurch( new_church ).$promise.then( $scope.onSaveChurch, $scope.onError );
								}
								return;
							}
							//google.maps.event.addListener(marker, 'click', function () {
							if ( church.cluster_count == 1 ) {
								//$scope.church = marker;

								$scope.edit_church = church;
								$scope.edit_church.editable = (($scope.current.assignment.team_role === 'leader' || $scope.current.assignment.team_role === 'inherited_leader') && church.ministry_id === $scope.current.assignment.ministry_id);

								$scope.$apply();
								$scope.churchWindow.close();
								$scope.churchWindow.setOptions( {maxWidth: 300} );
								$scope.churchWindow.open( $scope.map, marker );

								// $scope.churchWindow.open($scope.map, marker);
							}
							else {
								$scope.map.setCenter( marker.position );
								$scope.map.setZoom( $scope.map.getZoom() + 2 );
							}
						}
					}( church, marker, $scope )) );

					google.maps.event.addListener( marker, 'dragend', (function ( church, marker ) {
						return function () {

							//google.maps.event.addListener(marker, 'click', function () {
							if ( church.cluster_count == 1 ) {
								var new_church = {};
								new_church.id = church.id;
								new_church.latitude = marker.getPosition().lat();
								new_church.longitude = marker.getPosition().lng();
								church.latitude = new_church.latitude;
								church.longitude = new_church.longitude;
								churchService.saveChurch( new_church ).$promise.then( $scope.onSaveChurch, $scope.onError );

								marker.setAnimation( null );
								marker.setDraggable( false );
							}

						}
					}( church, marker )) );
					$scope.map.markers.push( marker );
				}


				//now create the parent lines
				angular.forEach( church.parents, function ( p ) {
					var par = $scope.churches.filter( function ( c ) {
						return c.id == p
					} );
					if ( par.length > 0 ) {
						var parentLine = new google.maps.Polyline( {
							path:          [new google.maps.LatLng( par[0].latitude, par[0].longitude ), new google.maps.LatLng( church.latitude, church.longitude )],
							geodesic:      true,
							strokeColor:   '#777',
							strokeOpacity: 1.0,
							strokeWeight:  2,
							icons:         [{
												icon:   {
													path:         google.maps.SymbolPath.FORWARD_OPEN_ARROW,
													strokeWeight: 1.5
												},
												offset: '12px',
												repeat: '25px'
											}]
						} );
						parentLine.setMap( $scope.map );
						$scope.map.church_lines.push( parentLine );
					}
				} );


			} );


		};


		$scope.jesusFilmSign = function ( coordinates, n, type ) {
			this.div_ = null;
			this.setMap( $scope.map );
			if ( n == 1 ) n = "JF";

			// onADD
			this.onAdd = function () {
				var div = document.createElement( 'div' );
				div.className = 'jf_label';
				div.innerHTML = n;
				this.div_ = div;
				var panes = this.getPanes();
				panes.overlayMouseTarget.appendChild( div );
			};

			// draw
			this.draw = function () {
				var div = this.div_;
				var overlayProjection = this.getProjection();
				var position = overlayProjection.fromLatLngToDivPixel( coordinates );

				// displacement of sign
				var x;
				var y;

				if ( type == 'cluster' ) {
					x = -20;
					y = 8;
				}

				else if ( type >= 0 && type <= 1 ) {
					x = -23;
					y = -12;
				}

				else if ( type == 2 ) {
					x = -22;
					y = -13;
				}

				else if ( type >= 3 ) {
					x = -20;
					y = -13;
				}

				else {
					x = 0;
					y = 0;
				}

				div.style.left = position.x + x + "px";
				div.style.top = position.y + y + "px";
			};

			this.onRemove = function () {
				this.div_.parentNode.removeChild( $scope.div_ );
				this.div_ = null;
			}
		};
		$scope.jesusFilmSign.prototype = new google.maps.OverlayView();

		$scope.setDefaultView = function () {
			var center = $scope.map.getCenter(),
				zoom = $scope.map.getZoom();

			// Update current assignment location/zoom
			$scope.current.assignment.location = {
				latitude:  center.lat(),
				longitude: center.lng()
			};
			$scope.current.assignment.location_zoom = zoom;

			// Save changes to API
			ministryService.updateMinistry( {
				ministry_id:   $scope.current.assignment.ministry_id,
				min_code:      $scope.current.assignment.min_code.trim(),
				location:      $scope.current.assignment.location,
				location_zoom: $scope.current.assignment.location_zoom
			} );
		};

		$scope.addTrainingStage = function ( training ) {
			var newPhase = {
				phase:            training.current_stage,
				date:             training.insert.date,
				number_completed: training.insert.number_completed,
				training_id:      training.hasOwnProperty( 'Id' ) ? training.Id : training.id

			};
			trainingService.addTrainingCompletion( $scope.current.sessionToken, newPhase ).then( $scope.onAddTrainingCompletion, $scope.onError );

			training.insert.date = "";
			training.insert.number_completed = 0;

		};

		$scope.onAddTrainingCompletion = function ( response ) {
			response.editMode = false;

			angular.forEach( $scope.assignment.trainings, function ( training ) {
				var id = training.hasOwnProperty( 'Id' ) ? training.Id : training.id;
				if ( id == response.training_id ) {
					training.gcm_training_completions.push( response );
					training.current_stage = response.phase + 1;
				}
			} );
		};

		$scope.saveTrainingCompletion = function ( data ) {
			trainingService.updateTrainingCompletion( $scope.current.sessionToken, data ).then( $scope.onSaveTrainingCompletion, $scope.onError );
		};
	}

	angular.module( 'gma.controllers.map' ).controller( 'MapCtrl', MapCtrl );
})( jQuery );

(function () {
	'use strict';

	function MeasurementDetailsCtrl( $scope, $modalInstance, measurementService, assignmentService, measurement, details, settings ) {
		$scope.spinner = true;
		$scope.measurement = measurement;
		$scope.details = details;
		$scope.ns = settings.gmaNamespace;

		$scope.details.$promise.then( function () {
			$scope.spinner = false;

			var da = [['Period', 'Local', 'Total', 'Personal']];
			angular.forEach( details.total, function ( t, period ) {
				angular.forEach( details.local, function ( l, p ) {
					if ( p === period ) {
						angular.forEach( details.my_measurements, function ( m, p ) {
							if ( p === period ) da.push( [p, l, t, m] )
						} );
					}
				} );
			} );
			$scope.trend = google.visualization.arrayToDataTable( da );
		} );

		$scope.filterSource = function ( items ) {
			var result = {};
			angular.forEach( items, function ( value, key ) {
				if ( key != settings.gmaNamespace && key != 'total' ) {
					result[key] = value;
				}
			} );
			return result;
		};

		$scope.save = function () {
			$scope.spinner = true;
			var measurements = [];
			angular.forEach( ['local', 'person'], function ( type ) {
				if ( $scope.editForm.hasOwnProperty( type ) && $scope.editForm[type].$dirty && typeof $scope.editForm[type] !== 'undefined' ) {
					measurements.push( {
						period:              $scope.current.period.format( 'YYYY-MM' ),
						mcc:                 $scope.current.mcc + '_' + settings.gmaNamespace,
						measurement_type_id: $scope.details.measurement_type_ids[type],
						related_entity_id:   type == 'local'
							? $scope.current.assignment.ministry_id
							: $scope.current.assignment.id,
						value:               $scope.editForm[type].$modelValue
					} );
				}
			} );

			if ( measurements.length > 0 ) {
				measurementService.saveMeasurement( {}, measurements, function () {
					$modalInstance.close();
				} );
			}
			else {
				$modalInstance.dismiss( 'cancel' );
			}
		};

		$scope.close = function () {
			$modalInstance.dismiss( 'cancel' );
		};

		$scope.approveSelfAssigned = function ( user, role ) {
			var user = user;
			user.state = 'pending';
			assignmentService.saveAssignment( {
				assignment_id: user.assignment_id
			}, {team_role: role}, function () {
				if ( role == 'blocked' ) {
					user.state = 'blocked';
					user.blocked = true;
				} else {
					user.success = true;
					user.state = 'member';
				}
			}, function () {
				delete user.state;
			} );
		};
	}

	angular.module( 'gma.controllers.measurements' ).controller( 'MeasurementDetailsCtrl', MeasurementDetailsCtrl );
})();

(function () {
	'use strict';

	function MeasurementsCtrl( $scope, $document, $filter, $modal, measurementService, settings ) {
		$scope.current.isLoaded = false;
		$scope.ns = settings.gmaNamespace;

		// Debounced method to fetch Measurements at most once every 100 milliseconds
		var getMeasurements = _.debounce( function () {
			if ( typeof $scope.current.assignment !== 'undefined' && typeof $scope.current.period !== 'undefined' && typeof $scope.current.mcc !== 'undefined' ) {
				$scope.current.isLoaded = false;
				$scope.lmiForm.$setPristine();
				$scope.measurements = measurementService.getMeasurements( {
					ministry_id: $scope.current.assignment.ministry_id,
					mcc:         $scope.current.mcc,
					period:      $scope.current.period.format( 'YYYY-MM' )
				}, function () {
					$scope.current.isLoaded = true;
				} );
			}
		}, 100 );

		$scope.$watch( 'current.assignment.ministry_id', function () {
			getMeasurements();
		} );

		$scope.$watch( 'current.mcc', function () {
			getMeasurements();
		} );

		$scope.$watch( 'current.period', function () {
			getMeasurements();
		} );

		$scope.hasOther = function () {
			return _.where( $scope.measurements, {section: 'other', column: 'other'} ).length > 0;
		};

		// Method used to save measurements for self_assigned role.
		$scope.save = function () {
			var measurements = [];
			angular.forEach( $scope.measurements, function ( measurement ) {
				var value = $scope.lmiForm[measurement.perm_link];
				if ( value.$dirty && value.$valid ) {
					this.push( {
						period:              $scope.current.period.format( 'YYYY-MM' ),
						mcc:                 $scope.current.mcc + '_' + settings.gmaNamespace,
						measurement_type_id: measurement.measurement_type_ids.person,
						related_entity_id:   $scope.current.assignment.id,
						value:               value.$modelValue
					} );
				}
			}, measurements );

			if ( measurements.length > 0 ) {
				measurementService.saveMeasurement( {}, measurements, function () {
					getMeasurements();
				} );
			}
			else {
				getMeasurements();
			}
		};

		$scope.editMeasurementDetails = function ( measurement ) {
			var instance = $modal.open( {
				templateUrl: 'partials/measurements/details.html',
				controller:  'MeasurementDetailsCtrl',
				keyboard:    true,
				backdrop:    true,
				resolve:     {
					'measurement': function () {
						return measurement;
					},
					'details':     function () {
						// Return the promise so resolve waits
						return measurementService.getMeasurement( {
							measurement_id: measurement.measurement_id,
							ministry_id:    $scope.current.assignment.ministry_id,
							mcc:            $scope.current.mcc,
							period:         $scope.current.period.format( 'YYYY-MM' )
						} );
					}
				}
			} );
			instance.result.then( function () {
				getMeasurements();
			} );
		};
	}

	angular.module( 'gma.controllers.measurements' ).controller( 'MeasurementsCtrl', MeasurementsCtrl );
})();

(function () {
	'use strict';

	function ReportsCtrl( $scope, $document, measurementService, settings ) {
		$scope.chart = new google.visualization.LineChart( document.getElementById( 'reports-chart' ) );
		$scope.table = new google.visualization.Table( document.getElementById( 'reports-table' ) );

		// Debounced method to fetch Measurements at most once every 100 milliseconds
		var getMeasurements = _.debounce( function () {
			if ( typeof $scope.current.assignment !== 'undefined' && typeof $scope.current.period !== 'undefined' && typeof $scope.current.mcc !== 'undefined' ) {
				delete $scope.dataTable;
				$scope.current.isLoaded = false;
				$scope.measurements = measurementService.getMeasurements( {
					ministry_id: $scope.current.assignment.ministry_id,
					mcc:         $scope.current.mcc,
					period:      $scope.current.period.format( 'YYYY-MM' ),
					historical:  true
				}, function () {
					$scope.current.isLoaded = true;

					var chartData = new google.visualization.DataTable(),
						tableData = new google.visualization.DataTable(),
						rows = [];
					chartData.addColumn( 'string', 'Date' );
					angular.forEach( $scope.dates, function ( date, index ) {
						rows[index] = [date];
						angular.forEach( $scope.measurements, function ( measurement ) {
							if ( index === 0 ) {
								chartData.addColumn( 'number', measurement.name );
							}
							rows[index].push( measurement.total[date] );
						} );
					} );
					chartData.addRows( rows );
					$scope.dataTable = chartData;

					tableData.addColumn( 'string', 'Measurement' );
					angular.forEach( $scope.measurements, function ( measurement, index ) {
						var row = [];
						angular.forEach( $scope.dates, function ( date ) {
							if ( index === 0 ) tableData.addColumn( 'number', date );
							row.push( measurement.total[date] );
						} );
						if ( index === 0 ) tableData.addColumn( 'number', 'Total' );
						tableData.addRow( [measurement.name].concat( row, [walterMeanAvg( row )] ) );
					} );
					$scope.tableDataTable = tableData;
				}, function () {
				} );
			}
		}, 100 );

		$scope.$watch( 'current.assignment.ministry_id', function () {
			getMeasurements();
		} );

		$scope.$watch( 'current.mcc', function () {
			getMeasurements();
		} );

		$scope.$watch( 'current.period', function ( period ) {
			if ( typeof period === 'undefined' ) return;
			getMeasurements();

			var now = period.clone(),
				dates = [];
			for ( var i = 0; i < 12; i++ ) {
				dates.push( now.clone().format( 'YYYY-MM' ) );
				now.subtract( 1, 'M' );
			}
			$scope.dates = dates.reverse();
		} );

		$scope.$watch( 'dataTable', function ( data ) {
			if ( typeof data === 'undefined' ) return;
			$scope.chart.draw( data, {
				chartArea:   {
					top:    20,
					left:   50,
					width:  '80%',
					height: '90%'
				},
				legend:      {
					alignment: 'start',
					position:  'right'
				},
				orientation: 'horizontal'
			} );
		} );

		$scope.$watch( 'tableDataTable', function ( data ) {
			if ( typeof data === 'undefined' ) return;
			$scope.table.draw( data, {} );
		} );

		function walterMeanAvg( data ) {
			// Drop zeros
			var values = [],
				total = 0;
			angular.forEach( data, function ( val ) {
				if ( val === 0 ) return;
				values.push( val );
			} );

			if ( values.length === 0 ) return 0;

			if ( values.length > 4 ) {
				// Sort array
				values.sort( function ( a, b ) {
					return a - b;
				} );

				// Remove first element, lowest
				values.shift();

				// Remove last element, highest
				values.pop();
			}

			// Sum the values
			angular.forEach( values, function ( val ) {
				total = total + val;
			} );

			// Return the average
			return Math.round( (total / values.length) * 100 ) / 100;
		}
	}

	angular.module( 'gma.controllers.reports' ).controller( 'ReportsCtrl', ReportsCtrl );
})();

(function () {
	'use strict';

	function assignmentService( $resource, settings ) {
		return $resource( settings.api.measurements( '/assignments/:assignment_id' ), {assignment_id: '@assignment_id'}, {
			getAssignment:  {method: 'GET'},
			getAssignments: {method: 'GET', isArray: true},
			saveAssignment: {method: 'PUT'},
			addTeamMember:  {method: 'POST'}
		} );
	}

	angular.module( 'gma.services.measurements' ).factory( 'assignmentService', assignmentService );
})();

(function () {
	'use strict';

	function churchService( $resource, settings ) {
		return $resource( settings.api.measurements( '/churches/:church_id' ), {}, {
			getChurch:   {method: 'GET'},
			getChurches: {method: 'GET', isArray: true},
			addChurch:   {method: 'POST'},
			saveChurch:  {method: 'PUT', params: {church_id: '@id'}}
		} );
	}

	angular.module( 'gma.services.measurements' ).factory( 'churchService', churchService );
})();

(function () {
	'use strict';

	function measurementService( $resource, settings ) {
		return $resource( settings.api.measurements( '/measurements/:measurement_id' ), {}, {
			getMeasurement:  {method: 'GET'},
			getMeasurements: {method: 'GET', isArray: true, params: {source: settings.gmaNamespace}},
			saveMeasurement: {method: 'POST'}
		} );
	}

	angular.module( 'gma.services.measurements' ).factory( 'measurementService', measurementService );
})();

(function () {
	'use strict';

	function measurementTypeService( $resource, settings ) {
		return $resource( settings.api.measurements( '/measurement_types/:measurement_type_id' ), {}, {
			getMeasurementType:  {method: 'GET'},
			getMeasurementTypes: {method: 'GET', isArray: true},
			saveMeasurementType: {method: 'PUT'},
			addMeasurementType:  {method: 'POST'}
		} );
	}

	angular.module( 'gma.services.measurements' ).factory( 'measurementTypeService', measurementTypeService );
})();

(function () {
	'use strict';

	function ministryService( $resource, settings ) {
		return $resource( settings.api.measurements( '/ministries/:ministry_id' ), {}, {
			getMinistry:    {method: 'GET'},
			getMinistries:  {method: 'GET', isArray: true},
			updateMinistry: {method: 'PUT', params: {ministry_id: '@ministry_id'}},
			createMinistry: {method: 'POST'}
		} );
	}

	angular.module( 'gma.services.measurements' ).factory( 'ministryService', ministryService );

})();

(function () {
	'use strict';

	function sessionService( $rootScope, $injector, $q, $location, $log, settings ) {
		var token,
			queue = [];

		var startSession = function ( ticket ) {
			if ( "false" === ticket ) {
				window.location = settings.api.login;
				return false;
			}
			return $injector.get( '$http' ).get( settings.api.measurements( '/token' ), {params: {st: ticket}} )
				.then( function ( response ) {
					$rootScope.current.user = response.data.user;
					$rootScope.current.sessionToken = response.data.session_ticket;
					token = response.data.session_ticket;
					if ( typeof response.data.assignments === 'object' ) {
						$rootScope.current.assignments = response.data.assignments;
					} else {
						delete $rootScope.current.assignments;
					}

					$rootScope.$broadcast( 'sessionStart', response.data );

					return response.data;
				} );
		};

		return {
			startSession:  function ( ticket ) {
				startSession( ticket );
			},
			logout:        function () {
				return $injector.get( '$http' ).delete( settings.api.measurements( '/token' ) );
			},
			// Request Interceptor
			request:       function ( config ) {
				if ( config.url.indexOf( settings.api.measurements() ) !== -1 ) {
					// All API requests must pass along HTTP credentials
					config.withCredentials = true;

					// If we have a toekn, add it to the request
					if ( typeof token !== 'undefined' ) {
						config.headers['Authorization'] = 'Bearer ' + token;
					}

					config.attempts = ( typeof config.attempts === 'number' ) ? config.attempts + 1 : 1;
				}
				return config;
			},
			// Error Response Interceptor
			responseError: function ( response ) {
				if ( response.status == 401 && response.config.url.indexOf( settings.api.measurements() ) !== -1 && response.config.attempts < 2 ) {
					$log.debug( response );

					var deferred = $q.defer();
					$injector.get( '$http' ).get( settings.api.refresh, {withCredentials: true} ).then( function ( loginResponse ) {
						if ( loginResponse.data ) {
							//get new token
							startSession( loginResponse.data.service_ticket ).then( function () {
								//retry request with new token
								$injector.get( '$http' )( response.config ).then( function ( response ) {
									deferred.resolve( response );
								}, function ( response ) {
									deferred.reject();
								} );
							} );
						} else {
							deferred.reject();
						}
					}, function ( response ) {
						deferred.reject();
						//redirect the CAS login
					} );
					return deferred.promise;
				}
				return $q.reject( response );
			}
		}
	}

	angular.module( 'gma.services.measurements' ).factory( 'sessionService', sessionService );
})();

(function () {
	'use strict';

	function trainingService( $http, settings ) {
		function getHighest( array ) {
			var max = 0;
			if ( !array ) return 0;
			for ( var i = 0; i < array.length; i++ ) {
				if ( array[i].phase > (max || 0) ) {
					max = array[i].phase;
				}
			}

			return max;
		}

		function getHighestCount( array ) {
			var max = 0;
			for ( var i = 0; i < array.length; i++ ) {
				if ( array[i].number_completed > (max || 0) ) {
					max = array[i].number_completed;
				}
			}

			return max;
		}

		return {
			getTrainings:             function ( session_ticket, ministry_id, mcc, show_all, show_tree ) {
				return $http
					.get( settings.api.measurements( '/training' ), {
						params: {
							ministry_id: ministry_id,
							show_all:    show_all,
							show_tree:   show_tree,
							mcc:         mcc
						}
					} )
					.then( function ( response ) {

						angular.forEach( response.data, function ( training ) {
							training.current_stage = getHighest( training.gcm_training_completions ) + 1;
							training.leaders_trained = getHighestCount( training.gcm_training_completions );
							training.editMode = false;
						} );

						return response.data;
					} );
			},
			updateTraining:           function ( session_ticket, training ) {
				var id = training.hasOwnProperty( 'Id' ) ? training.Id : training.id;
				return $http.put( settings.api.measurements( '/training/' + id ), training )
					.then( function ( response ) {
						return response.data;
					} );
			},
			addTraining:              function ( session_ticket, training ) {
				return $http.post( settings.api.measurements( '/training' ), training )
					.then( function ( response ) {
						return response.data;
					} );
			},
			deleteTraining:           function ( session_ticket, training ) {
				var id = training.hasOwnProperty( 'Id' ) ? training.Id : training.id;
				return $http.delete( settings.api.measurements( '/training/' + id ) )
					.then( function ( response ) {
						return;
					} );
			},
			addTrainingCompletion:    function ( session_ticket, training_completion ) {
				return $http.post( settings.api.measurements( '/training_completion' ), training_completion )
					.then( function ( response ) {
						return response.data;
					} );
			},
			updateTrainingCompletion: function ( session_ticket, training_completion ) {
				var id = training_completion.hasOwnProperty( 'Id' ) ? training_completion.Id : training_completion.id;
				return $http.put( settings.api.measurements( '/training_completion/' + id ), training_completion )
					.then( function ( response ) {
						return response.data;
					} );
			},
			deleteTrainingCompletion: function ( session_ticket, training_completion ) {
				var id = training_completion.hasOwnProperty( 'Id' ) ? training_completion.Id : training_completion.id;
				return $http.delete( settings.api.measurements( '/training_completion/' + id ) )
					.then( function ( response ) {
						return;
					} );
			}
		}
	}

	angular.module( 'gma.services.measurements' ).factory( 'trainingService', trainingService );
})();

(function () {
	'use strict';

	function settingsService() {
		var config = {};

		this.setConfig = function ( c ) {
			config = c;
		};

		var versionUrl = function ( path ) {
			return path.indexOf( '?' ) === -1
				? path + '?ver=' + config.version
				: path + '&ver=' + config.version;
		};

		var appUrl = function ( path, version ) {
			version = typeof version === 'undefined' ? true : version;
			var url = apiUrl( config.appUrl, path );
			if ( version ) {
				return versionUrl( url );
			}
			return url;
		};

		var measurementsApi = function ( path ) {
			return apiUrl( config.api.measurements, path );
		};

		function apiUrl( base, path ) {
			if ( typeof path === 'undefined' ) return base;
			return ( path.indexOf( '/' ) === 0 )
				? base + path
				: base + '/' + path;
		}

		var mobileApps = function () {
			if ( typeof config.mobileapps === 'undefined' ) return false;
			return config.mobileapps.length > 0 ? config.mobileapps : false;
		};

		this.routes = function () {
			var returnTabs = [];
			angular.forEach( config.enabled_tabs, function ( tab ) {
				switch ( tab ) {
					case 'map':
						returnTabs.push( {
							name:          'Church',
							path:          '/map',
							templateUrl:   'partials/map/map.html',
							controller:    'MapCtrl',
							requiredRoles: ['self_assigned', 'member', 'inherited_leader', 'leader']
						} );
						break;
					case 'measurements':
						returnTabs.push( {
							name:          'Measurements',
							path:          '/measurements',
							templateUrl:   'partials/measurements/measurements.html',
							controller:    'MeasurementsCtrl',
							requiredRoles: ['self_assigned', 'member', 'inherited_leader', 'leader']
						} );
						break;
					case 'reports':
						returnTabs.push( {
							name:          'Reports',
							path:          '/reports',
							templateUrl:   'partials/reports/reports.html',
							controller:    'ReportsCtrl',
							requiredRoles: ['inherited_leader', 'leader']
						} );
						break;
					case 'admin':
						returnTabs.push( {
							name:          'Admin',
							path:          '/admin',
							templateUrl:   'partials/admin/admin.html',
							controller:    'AdminCtrl',
							requiredRoles: ['leader', 'inherited_leader']
						} );
						break;
				}
			} );
			config.enabledTabs = returnTabs;
			return returnTabs;
		};

		this.$get = function () {
			return {
				appUrl:       appUrl,
				versionUrl:   versionUrl,
				ticket:       config.ticket,
				api:          {
					measurements: measurementsApi,
					refresh:      config.api.refresh,
					logout:       config.api.logout,
					login:        config.api.login
				},
				mobileApps:   ( typeof config.mobileapps !== 'undefined' && config.mobileapps.length > 0  ) ? config.mobileapps : false,
				gmaNamespace: config.namespace,
				enabledTabs:  config.enabledTabs
			}
		};
	}

	angular.module( 'gma.services.settings' ).provider( 'settings', settingsService );
})();
